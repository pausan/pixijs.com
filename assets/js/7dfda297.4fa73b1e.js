"use strict";(self.webpackChunkpixi_docusaurus=self.webpackChunkpixi_docusaurus||[]).push([[3421],{84970:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var a=n(87462),i=(n(67294),n(3905));const o={},r="Scene Graph",s={unversionedId:"guides/basics/scene-graph",id:"guides/basics/scene-graph",title:"Scene Graph",description:"Every frame, PixiJS is updating and then rendering the scene graph.  Let's talk about what's in the scene graph, and how it impacts how you develop your project.  If you've built games before, this should all sound very familiar, but if you're coming from HTML and the DOM, it's worth understanding before we get into specific types of objects you can render.",source:"@site/docs/guides/basics/scene-graph.md",sourceDirName:"guides/basics",slug:"/guides/basics/scene-graph",permalink:"/8.x/guides/basics/scene-graph",draft:!1,editUrl:"https://github.com/pixijs/pixijs.com/tree/main/docs/guides/basics/scene-graph.md",tags:[],version:"current",frontMatter:{},sidebar:"guidesSidebar",previous:{title:"Render Loop",permalink:"/8.x/guides/basics/render-loop"},next:{title:"Render Groups",permalink:"/8.x/guides/advanced/render-groups"}},l={},d=[{value:"The Scene Graph Is a Tree",id:"the-scene-graph-is-a-tree",level:2},{value:"Parents and Children",id:"parents-and-children",level:2},{value:"Render Order",id:"render-order",level:2},{value:"RenderGroups",id:"rendergroups",level:2},{value:"Culling",id:"culling",level:2},{value:"Local vs Global Coordinates",id:"local-vs-global-coordinates",level:2},{value:"Global vs Screen Coordinates",id:"global-vs-screen-coordinates",level:2}],p={toc:d};function c(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"scene-graph"},"Scene Graph"),(0,i.kt)("p",null,"Every frame, PixiJS is updating and then rendering the scene graph.  Let's talk about what's in the scene graph, and how it impacts how you develop your project.  If you've built games before, this should all sound very familiar, but if you're coming from HTML and the DOM, it's worth understanding before we get into specific types of objects you can render."),(0,i.kt)("h2",{id:"the-scene-graph-is-a-tree"},"The Scene Graph Is a Tree"),(0,i.kt)("p",null,"The scene graph's root node is a container maintained by the application, and referenced with ",(0,i.kt)("inlineCode",{parentName:"p"},"app.stage"),".  When you add a sprite or other renderable object as a child to the stage, it's added to the scene graph and will be rendered and interactable.  PixiJS ",(0,i.kt)("inlineCode",{parentName:"p"},"Containers")," can also have children, and so as you build more complex scenes, you will end up with a tree of parent-child relationships, rooted at the app's stage."),(0,i.kt)("p",null,"(A helpful tool for exploring your project is the ",(0,i.kt)("a",{parentName:"p",href:"https://chrome.google.com/webstore/detail/pixijs-devtools/aamddddknhcagpehecnhphigffljadon"},"Pixi.js devtools plugin")," for Chrome, which allows you to view and manipulate the scene graph in real time as it's running!)"),(0,i.kt)("h2",{id:"parents-and-children"},"Parents and Children"),(0,i.kt)("p",null,"When a parent moves, its children move as well.  When a parent is rotated, its children are rotated too.  Hide a parent, and the children will also be hidden.  If you have a game object that's made up of multiple sprites, you can collect them under a container to treat them as a single object in the world, moving and rotating as one."),(0,i.kt)("p",null,"Each frame, PixiJS runs through the scene graph from the root down through all the children to the leaves to calculate each object's final position, rotation, visibility, transparency, etc.  If a parent's alpha is set to 0.5 (making it 50% transparent), all its children will start at 50% transparent as well.  If a child is then set to 0.5 alpha, it won't be 50% transparent, it will be 0.5 x 0.5 = 0.25 alpha, or 75% transparent.  Similarly, an object's position is relative to its parent, so if a parent is set to an x position of 50 pixels, and the child is set to an x position of 100 pixels, it will be drawn at a screen offset of 150 pixels, or 50 + 100."),(0,i.kt)("p",null,"Here's an example.  We'll create three sprites, each a child of the last, and animate their position, rotation, scale and alpha.  Even though each sprite's properties are set to the same values, the parent-child chain amplifies each change:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// Create the application helper and add its render target to the page\nconst app = new Application();\nawait app.init({ width: 640, height: 360 })\ndocument.body.appendChild(app.canvas);\n\n// Add a container to center our sprite stack on the page\nconst container = new Container({\n  x:app.screen.width / 2,\n  y:app.screen.height / 2\n});\n\napp.stage.addChild(container);\n\n// load the texture\nawait Assets.load('assets/images/sample.png');\n\n// Create the 3 sprites, each a child of the last\nconst sprites = [];\nlet parent = container;\nfor (let i = 0; i < 3; i++) {\n  let wrapper = new Container();\n  let sprite = Sprite.from('assets/images/sample.png');\n  sprite.anchor.set(0.5);\n  wrapper.addChild(sprite);\n  parent.addChild(wrapper);\n  sprites.push(wrapper);\n  parent = wrapper;\n}\n\n// Set all sprite's properties to the same value, animated over time\nlet elapsed = 0.0;\napp.ticker.add((delta) => {\n  elapsed += delta.deltaTime / 60;\n  const amount = Math.sin(elapsed);\n  const scale = 1.0 + 0.25 * amount;\n  const alpha = 0.75 + 0.25 * amount;\n  const angle = 40 * amount;\n  const x = 75 * amount;\n  for (let i = 0; i < sprites.length; i++) {\n    const sprite = sprites[i];\n    sprite.scale.set(scale);\n    sprite.alpha = alpha;\n    sprite.angle = angle;\n    sprite.x = x;\n  }\n});\n")),(0,i.kt)("p",null,"The cumulative translation, rotation, scale and skew of any given node in the scene graph is stored in the object's ",(0,i.kt)("inlineCode",{parentName:"p"},"worldTransform")," property.  Similarly, the cumulative alpha value is stored in the ",(0,i.kt)("inlineCode",{parentName:"p"},"worldAlpha")," property."),(0,i.kt)("h2",{id:"render-order"},"Render Order"),(0,i.kt)("p",null,"So we have a tree of things to draw.  Who gets drawn first?"),(0,i.kt)("p",null,"PixiJS renders the tree from the root down.  At each level, the current object is rendered, then each child is rendered in order of insertion.  So the second child is rendered on top of the first child, and the third over the second."),(0,i.kt)("p",null,"Check out this example, with two parent objects A & D, and two children B & C under A:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"// Create the application helper and add its render target to the page\nconst app = new Application();\nawait app.init({ width: 640, height: 360 })\ndocument.body.appendChild(app.canvas);\n\n// Label showing scene graph hierarchy\nconst label = new Text({\n  text:'Scene Graph:\\n\\napp.stage\\n  \u2517 A\\n     \u2517 B\\n     \u2517 C\\n  \u2517 D',\n  style:{fill: '#ffffff'},\n  position: {x: 300, y: 100}\n});\n\napp.stage.addChild(label);\n\n// Helper function to create a block of color with a letter\nconst letters = [];\nfunction addLetter(letter, parent, color, pos) {\n  const bg = new Sprite(Texture.WHITE);\n  bg.width = 100;\n  bg.height = 100;\n  bg.tint = color;\n\n  const text = new Text({\n    text:letter,\n    style:{fill: \"#ffffff\"}\n  });\n\n  text.anchor.set(0.5);\n  text.position = {x: 50, y: 50};\n\n  const container = new Container();\n  container.position = pos;\n  container.visible = false;\n  container.addChild(bg, text);\n  parent.addChild(container);\n\n  letters.push(container);\n  return container;\n}\n\n// Define 4 letters\nlet a = addLetter('A', app.stage, 0xff0000, {x: 100, y: 100});\nlet b = addLetter('B', a,         0x00ff00, {x: 20,  y: 20});\nlet c = addLetter('C', a,         0x0000ff, {x: 20,  y: 40});\nlet d = addLetter('D', app.stage, 0xff8800, {x: 140, y: 100});\n\n// Display them over time, in order\nlet elapsed = 0.0;\napp.ticker.add((ticker) => {\n  elapsed += ticker.deltaTime / 60.0;\n  if (elapsed >= letters.length) { elapsed = 0.0; }\n  for (let i = 0; i < letters.length; i ++) {\n    letters[i].visible = elapsed >= i;\n  }\n});\n")),(0,i.kt)("p",null,"If you'd like to re-order a child object, you can use ",(0,i.kt)("inlineCode",{parentName:"p"},"setChildIndex()"),".  To add a child at a given point in a parent's list, use ",(0,i.kt)("inlineCode",{parentName:"p"},"addChildAt()"),".  Finally, you can enable automatic sorting of an object's children using the ",(0,i.kt)("inlineCode",{parentName:"p"},"sortableChildren")," option combined with setting the ",(0,i.kt)("inlineCode",{parentName:"p"},"zIndex")," property on each child."),(0,i.kt)("h2",{id:"rendergroups"},"RenderGroups"),(0,i.kt)("p",null,"As you delve deeper into PixiJS, you'll encounter a powerful feature known as Render Groups. Think of Render Groups as specialized containers within your scene graph that act like mini scene graphs themselves. Here's what you need to know to effectively use Render Groups in your projects. For more info check out the ",(0,i.kt)("a",{parentName:"p",href:"../advanced/render-groups"},"RenderGroups overview")),(0,i.kt)("h2",{id:"culling"},"Culling"),(0,i.kt)("p",null,"If you're building a project where a large proportion of your scene objects are off-screen (say, a side-scrolling game), you will want to ",(0,i.kt)("em",{parentName:"p"},"cull")," those objects.  Culling is the process of evaluating if an object (or its children!) is on the screen, and if not, turning off rendering for it.  If you don't cull off-screen objects, the renderer will still draw them, even though none of their pixels end up on the screen."),(0,i.kt)("p",null,"PixiJS doesn't provide built-in support for viewport culling, but you can find 3rd party plugins that might fit your needs.  Alternately, if you'd like to build your own culling system, simply run your objects during each tick and set ",(0,i.kt)("inlineCode",{parentName:"p"},"renderable")," to false on any object that doesn't need to be drawn."),(0,i.kt)("h2",{id:"local-vs-global-coordinates"},"Local vs Global Coordinates"),(0,i.kt)("p",null,"If you add a sprite to the stage, by default it will show up in the top left corner of the screen.  That's the origin of the global coordinate space used by PixiJS.  If all your objects were children of the stage, that's the only coordinates you'd need to worry about.  But once you introduce containers and children, things get more complicated.  A child object at ","[50, 100]"," is 50 pixels right and 100 pixels down ",(0,i.kt)("em",{parentName:"p"},"from its parent"),"."),(0,i.kt)("p",null,'We call these two coordinate systems "global" and "local" coordinates.  When you use ',(0,i.kt)("inlineCode",{parentName:"p"},"position.set(x, y)")," on an object, you're always working in local coordinates, relative to the object's parent."),(0,i.kt)("p",null,"The problem is, there are many times when you want to know the global position of an object.  For example, if you want to cull offscreen objects to save render time, you need to know if a given child is outside the view rectangle."),(0,i.kt)("p",null,"To convert from local to global coordinates, you use the ",(0,i.kt)("inlineCode",{parentName:"p"},"toGlobal()")," function.  Here's a sample usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"// Get the global position of an object, relative to the top-left of the screen\nlet globalPos = obj.toGlobal(new Point(0,0));\n")),(0,i.kt)("p",null,"This snippet will set ",(0,i.kt)("inlineCode",{parentName:"p"},"globalPos")," to be the global coordinates for the child object, relative to ","[0, 0]"," in the global coordinate system."),(0,i.kt)("h2",{id:"global-vs-screen-coordinates"},"Global vs Screen Coordinates"),(0,i.kt)("p",null,'When your project is working with the host operating system or browser, there is a third coordinate system that comes into play - "screen" coordinates (aka "viewport" coordinates).  Screen coordinates represent position relative to the top-left of the canvas element that PixiJS is rendering into.  Things like the DOM and native mouse click events work in screen space.'),(0,i.kt)("p",null,"Now, in many cases, screen space is equivalent to world space.  This is the case if the size of the canvas is the same as the size of the render view specified when you create you ",(0,i.kt)("inlineCode",{parentName:"p"},"Application"),".  By default, this will be the case - you'll create for example an 800x600 application window and add it to your HTML page, and it will stay that size.  100 pixels in world coordinates will equal 100 pixels in screen space.  BUT!  It is common to stretch the rendered view to have it fill the screen, or to render at a lower resolution and up-scale for speed.  In that case, the screen size of the canvas element will change (e.g. via CSS), but the underlying render view will ",(0,i.kt)("em",{parentName:"p"},"not"),", resulting in a mis-match between world coordinates and screen coordinates."))}c.isMDXComponent=!0}}]);