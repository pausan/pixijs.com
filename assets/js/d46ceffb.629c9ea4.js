"use strict";(self.webpackChunkpixi_docusaurus=self.webpackChunkpixi_docusaurus||[]).push([[1074],{75634:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var n=a(87462),i=(a(67294),a(3905));const r={},s="Cache As Texture",o={unversionedId:"guides/advanced/cache-as-texture",id:"guides/advanced/cache-as-texture",title:"Cache As Texture",description:"Using cacheAsTexture in PixiJS",source:"@site/docs/guides/advanced/cache-as-texture.md",sourceDirName:"guides/advanced",slug:"/guides/advanced/cache-as-texture",permalink:"/8.x/guides/advanced/cache-as-texture",draft:!1,editUrl:"https://github.com/pixijs/pixijs.com/tree/main/docs/guides/advanced/cache-as-texture.md",tags:[],version:"current",frontMatter:{},sidebar:"guidesSidebar",previous:{title:"Render Groups",permalink:"/8.x/guides/advanced/render-groups"},next:{title:"Assets",permalink:"/8.x/guides/components/assets"}},l={},c=[{value:"Using <code>cacheAsTexture</code> in PixiJS",id:"using-cacheastexture-in-pixijs",level:3},{value:"What Is <code>cacheAsTexture</code>?",id:"what-is-cacheastexture",level:3},{value:"Basic Usage",id:"basic-usage",level:3},{value:"Advanced Usage",id:"advanced-usage",level:3},{value:"Benefits of <code>cacheAsTexture</code>",id:"benefits-of-cacheastexture",level:3},{value:"Advanced Details",id:"advanced-details",level:3},{value:"How It Works Internally",id:"how-it-works-internally",level:3},{value:"Best Practices",id:"best-practices",level:3},{value:"<strong>DO</strong>:",id:"do",level:4},{value:"<strong>DON&#39;T</strong>:",id:"dont",level:4},{value:"Gotchas",id:"gotchas",level:3}],u={toc:c};function d(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"cache-as-texture"},"Cache As Texture"),(0,i.kt)("h3",{id:"using-cacheastexture-in-pixijs"},"Using ",(0,i.kt)("inlineCode",{parentName:"h3"},"cacheAsTexture")," in PixiJS"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"cacheAsTexture")," function in PixiJS is a powerful tool for optimizing rendering in your applications. By rendering a container and its children to a texture, ",(0,i.kt)("inlineCode",{parentName:"p"},"cacheAsTexture")," can significantly improve performance for static or infrequently updated containers. Let's explore how to use it effectively, along with its benefits and considerations."),(0,i.kt)("admonition",{title:"Note",type:"info"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"cacheAsTexture")," is PixiJS v8's equivalent of the previous ",(0,i.kt)("inlineCode",{parentName:"p"},"cacheAsBitmap")," functionality. If you're migrating from v7 or earlier, simply replace ",(0,i.kt)("inlineCode",{parentName:"p"},"cacheAsBitmap")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"cacheAsTexture")," in your code.")),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"what-is-cacheastexture"},"What Is ",(0,i.kt)("inlineCode",{parentName:"h3"},"cacheAsTexture"),"?"),(0,i.kt)("p",null,"When you set ",(0,i.kt)("inlineCode",{parentName:"p"},"container.cacheAsTexture()"),", the container is rendered to a texture. Subsequent renders reuse this texture instead of rendering all the individual children of the container. This approach is particularly useful for containers with many static elements, as it reduces the rendering workload."),(0,i.kt)("p",null,"To update the texture after making changes to the container, call:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"container.updateCacheTexture();\n")),(0,i.kt)("p",null,"and to turn it off, call:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"container.cacheAsTexture(false);\n")),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"basic-usage"},"Basic Usage"),(0,i.kt)("p",null,"Here's an example that demonstrates how to use ",(0,i.kt)("inlineCode",{parentName:"p"},"cacheAsTexture"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"import * as PIXI from 'pixi.js';\n\n(async () =>\n{\n    // Create a new application\n    const app = new Application();\n\n    // Initialize the application\n    await app.init({ background: '#1099bb', resizeTo: window });\n\n    // Append the application canvas to the document body\n    document.body.appendChild(app.canvas);\n\n    // load sprite sheet..\n    await Assets.load('https://pixijs.com/assets/spritesheet/monsters.json');\n\n    // holder to store aliens\n    const aliens = [];\n    const alienFrames = ['eggHead.png', 'flowerTop.png', 'helmlok.png', 'skully.png'];\n\n    let count = 0;\n\n    // create an empty container\n    const alienContainer = new Container();\n\n    alienContainer.x = 400;\n    alienContainer.y = 300;\n\n    app.stage.addChild(alienContainer);\n\n    // add a bunch of aliens with textures from image paths\n    for (let i = 0; i < 100; i++)\n    {\n        const frameName = alienFrames[i % 4];\n\n        // create an alien using the frame name..\n        const alien = Sprite.from(frameName);\n\n        alien.tint = Math.random() * 0xffffff;\n\n        alien.x = Math.random() * 800 - 400;\n        alien.y = Math.random() * 600 - 300;\n        alien.anchor.x = 0.5;\n        alien.anchor.y = 0.5;\n        aliens.push(alien);\n        alienContainer.addChild(alien);\n    }\n\n    // this will cache the container and its children as a single texture\n    // so instead of drawing 100 sprites, it will draw a single texture!\n    alienContainer.cacheAsTexture()\n})();\n")),(0,i.kt)("p",null,"In this example, the ",(0,i.kt)("inlineCode",{parentName:"p"},"container")," and its children are rendered to a single texture, reducing the rendering overhead when the scene is drawn."),(0,i.kt)("p",null,"Play around with the example ",(0,i.kt)("a",{parentName:"p",href:"../../examples/basic/cache-as-texture"},"here"),"."),(0,i.kt)("h3",{id:"advanced-usage"},"Advanced Usage"),(0,i.kt)("p",null,"Instead of enabling cacheAsTexture with true, you can pass a configuration object which is very similar to texture source options."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"container.cacheAsTexture({\n    resolution: 2,\n    antialias: true,\n});\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"resolution")," is the resolution of the texture. By default this is the same as you renderer or application."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"antialias")," is the antialias mode to use for the texture. Much like the resolution this defaults to the renderer or application antialias mode.")),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"benefits-of-cacheastexture"},"Benefits of ",(0,i.kt)("inlineCode",{parentName:"h3"},"cacheAsTexture")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Performance Boost"),": Rendering a complex container as a single texture avoids the need to process each child element individually during each frame."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Optimized for Static Content"),": Ideal for containers with static or rarely updated children.")),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"advanced-details"},"Advanced Details"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Memory Tradeoff"),": Each cached texture requires GPU memory. Using ",(0,i.kt)("inlineCode",{parentName:"li"},"cacheAsTexture")," trades rendering speed for increased memory usage."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"GPU Limitations"),": If your container is too large (e.g., over 4096x4096 pixels), the texture may fail to cache, depending on GPU limitations.")),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"how-it-works-internally"},"How It Works Internally"),(0,i.kt)("p",null,"Under the hood, ",(0,i.kt)("inlineCode",{parentName:"p"},"cacheAsTexture")," converts the container into a render group and renders it to a texture. It uses the same texture cache mechanism as filters:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"container.enableRenderGroup();\ncontainer.renderGroup.cacheAsTexture = true;\n")),(0,i.kt)("p",null,"Once the texture is cached, updating it via ",(0,i.kt)("inlineCode",{parentName:"p"},"updateCacheTexture()")," is efficient and incurs minimal overhead. Its as fast as rendering the container normally."),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"best-practices"},"Best Practices"),(0,i.kt)("h4",{id:"do"},(0,i.kt)("strong",{parentName:"h4"},"DO"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Use for Static Content"),": Apply ",(0,i.kt)("inlineCode",{parentName:"li"},"cacheAsTexture")," to containers with elements that don't change frequently, such as a UI panel with static decorations."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Leverage for Performance"),": Use ",(0,i.kt)("inlineCode",{parentName:"li"},"cacheAsTexture")," to render complex containers as a single texture, reducing the overhead of processing each child element individually every frame. This is especially useful for containers that contain expensive effects eg filters."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Switch of Antialiasing"),": setting antialiasing to false can give a small performance boost, but the texture may look a bit more pixelated around its children's edges."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Resolution"),": Do adjust the resolution based on your situation, if something is scaled down, you can use a lower resolution.If something is scaled up, you may want to use a higher resolution. But be aware that the higher the resolution the larger the texture and memory footprint.")),(0,i.kt)("h4",{id:"dont"},(0,i.kt)("strong",{parentName:"h4"},"DON'T"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Apply to Very Large Containers"),": Avoid using ",(0,i.kt)("inlineCode",{parentName:"li"},"cacheAsTexture")," on containers that are too large (e.g., over 4096x4096 pixels), as they may fail to cache due to GPU limitations. Instead, split them into smaller containers."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Overuse for Dynamic Content"),": Flick ",(0,i.kt)("inlineCode",{parentName:"li"},"cacheAsTexture")," on / off frequently on containers, as this results in constant re-caching, negating its benefits. Its better to Cache as texture when you once, and then use ",(0,i.kt)("inlineCode",{parentName:"li"},"updateCacheTexture")," to update it."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Apply to Sparse Content"),": Do not use ",(0,i.kt)("inlineCode",{parentName:"li"},"cacheAsTexture")," for containers with very few elements or sparse content, as the performance improvement will be negligible."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Ignore Memory Impact"),": Be cautious of GPU memory usage. Each cached texture consumes memory, so overusing ",(0,i.kt)("inlineCode",{parentName:"li"},"cacheAsTexture")," can lead to resource constraints.")),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"gotchas"},"Gotchas"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Rendering Depends on Scene Visibility"),": The cache updates only when the containing scene is rendered. Modifying the layout after setting ",(0,i.kt)("inlineCode",{parentName:"p"},"cacheAsTexture")," but before rendering your scene will be reflected in the cache.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Containers are rendered with no transform"),": Cached items are rendered at their actual size, ignoring transforms like scaling. For instance, an item scaled down by 50%, its texture will be cached at 100% size and then scaled down by the scene.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Caching and Filters"),": Filters may not behave as expected with ",(0,i.kt)("inlineCode",{parentName:"p"},"cacheAsTexture"),". To cache the filter effect, wrap the item in a parent container and apply ",(0,i.kt)("inlineCode",{parentName:"p"},"cacheAsTexture")," to the parent.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Reusing the texture"),": If you want to create a new texture based on the container, its better to use ",(0,i.kt)("inlineCode",{parentName:"p"},"const texture = renderer.generateTexture(container)")," and share that amongst you objects!"))),(0,i.kt)("p",null,"By understanding and applying ",(0,i.kt)("inlineCode",{parentName:"p"},"cacheAsTexture")," strategically, you can significantly enhance the rendering performance of your PixiJS projects. Happy coding!"))}d.isMDXComponent=!0}}]);